\chapter{Funktionsweise und Teilprotokolle}

\lstdefinestyle{default}{
	numbers=none,
	frame=leftline,
	escapeinside={§}{§},
	emph={}
}

\lstdefinestyle{tls}{
	numbers=none,
	frame=none,%leftline,
	escapeinside={§}{§},
	emph={HelloRequest,ClientHello,ServerHello,Certificate,ServerKeyExchange,CertificateRequest,ServerHelloDone,ClientKeyExchange,CertificateVerify,ChangeCipherSpec,Finished,TLSCompressed,TLSCiphertext,TLSPlaintext,SecurityParameters},
	emphstyle=\textbf
}

\lstset{style=tls}

Die Informationen in diesem Abschnitt stammen überwiegend aus der TLS 1.2-Spezifikation (\cite{tls12}). Für einen ersten Überblick wurde \cite{eckert13} genutzt.
\todo{Zum Einstieg grobe Funktionsbeschreibung, evtl. schon mit Grafik über Verbindungsaufbau?, Grafik der TLS-Protokolle}

TLS besteht aus zwei Schichten. In der oberen Schicht sind vier Teilprotokolle spezifiziert: \handshakeprotocol{}, \changecipherspecprotocol{}, \alertprotocol{} und \applicationdataprotocol{}, auf die später eingegangen wird. In der unteren Schicht befindet sich das \recordprotocol{}, das die Daten von den Teilprotokollen der oberen Schicht entgegennimmt.

\section{Record Protocol}
\todo{Kapitel evtl. hinter den Handshake? Und vorher auf Schlüsselberechnung eingehen?}
Die zu sendenden Protokolldaten werden von dem \recordprotocol{} fragmentiert (in maximal \(2^{14}\) Byte große Pakete) und optional komprimiert. Danach wird je nach während des Handshakes verhandelten kryptographischen Funktionen (vgl. Abschnitt \ref{sec_tls_handshake}) die Integrität der Daten durch Berechnen und Anhängen eines MACs gesichert und die Nachricht verschlüsselt\footnote{Es wird MAC-then-Encrypt verwendet. Laut \cite{AE2000} ist Encrypt-then-MAC vorzuziehen. In \cite{krawczyk01} wird dieses Ergebnis bestätigt, aber auch die Sicherheit von MAC-then-encrypt unter bestimmten Voraussetzungen gezeigt.}. Auf diese Schritte wird im Folgenden genauer eingegangen.
\todo{Nach http://crypto.stackexchange.com/a/224 schlägt Schneier in Cryptography Engineering MAC-then-encrypt aus Gründen der Komplexheit von Encrypt-then-MAC vor. Nachlesen! Gibt es in der Informatik-Bibliothek: T FER 45399} 

Daten, die von einer höheren Schicht entgegengenommen werden, werden zu Beginn in ein \datafield{TLSPlaintext}-Objekt verpackt. 

\begin{lstlisting}
 struct {
	ContentType type;  
	ProtocolVersion version; 
	uint16 length;
	opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
\end{lstlisting}

%enum { //eher erklaeren als uebernehmen
%	change_cipher_spec(20), alert(21), handshake(22), application_data(23),(255)
%} ContentType;
%
%struct { //eher erklaeren als uebernehmen
%	uint8 major;
%	uint8 minor;
%} ProtocolVersion;

Der \datafield{Contenttype} steht für den Protokolltyp der Nachricht: \changecipherspecprotocol{} (20), \alertprotocol{} (21), \handshakeprotocol{} (22) oder \applicationdataprotocol{} (23). Die \datafield{ProtocolVersion} besteht aus zwei Bytes für die über- und untergeordnete Protokollnummer (z.B. (3,3) für TLS 1.2). Im \datafield{fragment} werden die zu übertragenden Daten gespeichert.

Danach werden die Daten optional durch den während des Handshakes vereinbarten Kompressionsalgorithmus komprimiert und in ein \datafield{TLSCompressed}-Objekt überführt.

\begin{lstlisting}
 struct {
	ContentType type;       /* same as TLSPlaintext.type */
	ProtocolVersion version;/* same as TLSPlaintext.version */
	uint16 length;
	opaque fragment[TLSCompressed.length];
} TLSCompressed;
\end{lstlisting}

Anschließend wird die Integrität der Daten mit einem MAC geschützt, der folgendermaßen berechnet wird:
\begin{lstlisting}
MAC(MAC_write_key, seq_num +
				   TLSCompressed.type +
				   TLSCompressed.version +
				   TLSCompressed.length +
				   TLSCompressed.fragment);
\end{lstlisting}
Bei den in TLS verwendeten \ciphersuites{} wird das HMAC-Verfahren zur Berechnung des MACs genutzt. Details zu diesem Verfahren sind in \cite{hmac97} zu finden. Die hierbei verwendete Hashfunktion wird in der \ciphersuite{} angegeben. Bei SSL 3.0 wurde hier noch eine HMAC-ähnliche Konstruktion verwendet.\todo{In Versionsunterschiede auslagern?}

Danach wird der Klartext zusammen mit dem MAC verschlüsselt, in ein \datafield{TLSCiphertext}-Objekt überführt und dann verschickt.

%p.21
\begin{lstlisting}
struct {
	ContentType type;       /* same as TLSCompressed.type */
	ProtocolVersion version;/* same as TLSCompressed.version */
	uint16 length;
	select (SecurityParameters.cipher_type) {
	    case stream: GenericStreamCipher;
	    case block:  GenericBlockCipher;
	    case aead:   GenericAEADCipher;
	} fragment;
} TLSCiphertext;
\end{lstlisting}

Abhängig vom verwendeten Verschlüsselungsverfahren sehen diese Nachrichten unterschiedlich aus. Bei Stromchiffren wird der MAC zusammen mit den Daten (\datafield{TLSCompressed.fragment}) verschlüsselt und übertragen. \\
Bei Blockchiffren werden die Daten zusammen mit dem MAC zuerst mit Padding versehen, um ein Vielfaches der Blocklänge als Länge zu erhalten. Jedes Padding-Byte enthält die Paddinglänge als Wert. Dann werden MAC und Daten zusammen verschlüsselt und mit dem für jede Nachricht zufällig generierten Initialisierungsvektor (IV) versendet.\\
% For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), p. 24  
Bei der Nutzung von AEAD-Chiffren\footnote{Authenticated Encryption with Associated Data: Betriebsmodi für Blockchiffren, die ohne zusätzlichen MAC Authentizität und Integrität bereitstellen. Beispiele für solche Modi sind CCM oder GCM.} werden bei der Verschlüsselung zusätzlich zum Klartext und Schlüssel zwei zusätzliche Parameter verwendet: eine sogenannte nonce (eine einmalig verwendete, zufällige Eingabe) und zusätzliche Daten, in die die Sequenznummer der Nachricht, ihr Typ, ihre Version und ihre Länge einfließen. Der explizite Teil der nonce wird neben den verschlüsselten Daten übertragen. Der implizite Teil wird durch server bzw. client write IV gebildet (vgl. Abschnitt \ref{sec_key_material}). Die Notwendigkeit einer MAC-Berechnung entfällt bei der Nutzung von AEAD-Chiffren.


\section{Berechnung des Schlüsselmaterials}
\label{sec_key_material}

Bei der Berechnung von Schlüsseln verwendet TLS eine eigene Konstruktion\footnote{Pseudorandom function (PRF)}, die standardmäßig für alle \ciphersuites{} verwendet wird und auf dem HMAC-Verfahren aufbaut:

\begin{lstlisting}
PRF(secret, label, seed) = P_hash(secret, label + seed)

P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
					   HMAC_hash(secret, A(2) + seed) +
					   HMAC_hash(secret, A(3) + seed) + ...
mit
A(0) = seed
A(i) = HMAC_hash(secret, A(i-1))
\end{lstlisting}

Nach der \clientkeyexchange{}-Nachricht sind Client und Server im Besitz des \premastersecret{}. Aus diesem und den in den Hello-Nachrichten übertragenen random-Werten wird nun auf beiden Seiten das \mastersecret{} folgendermaßen generiert:

\begin{lstlisting}
master_secret = PRF(pre_master_secret, 
					"master secret",
					ClientHello.random + ServerHello.random)[0..47];
\end{lstlisting}

Aus diesem \mastersecret{} werden je nach verwendeten kryptographischen Verfahren Schlüssel für die Erstellung des MACs, für die Verschlüsselung zwischen Client und Server und für eine zusätzliche Eingabe bei AEAD-Chiffren berechnet:
\begin{lstlisting}
client write MAC key
server write MAC key
client write encryption key
server write encryption key
client write IV
server write IV
\end{lstlisting}

Dazu werden solange Schlüsselblöcke nach dem folgenden Verfahren erstellt, bis genug Daten vorhanden sind um alle benötigten Schlüssel konstruieren zu können: 

\begin{lstlisting}
key_block = PRF(SecurityParameters.master_secret,
                "key expansion",
                SecurityParameters.server_random +
                SecurityParameters.client_random);
\end{lstlisting}


\section{TLS-Handshake}

\label{sec_tls_handshake}

Das \handshakeprotocol{} dient zur Herstellung einer gesicherten Verbindung. Hierbei werden kryptographische Verfahren zwischen den Kommunikationspartnern vereinbart, optional ihre Identitäten authentifiziert und ein gemeinsames Geheimnis (das sogenannte \premastersecret{}) für die bereits beschriebene Generierung der während der eigentlichen Kommunikation verwendeten Schlüssel übertragen oder berechnet. Eine Übersicht über die während eines vollständigen Handshakes ausgetauschten Nachrichten bietet Abbildung \ref{fig_complete_handshake}. 

Im Folgenden werden diese Nachrichten und ihr Aufbau im Detail betrachtet. Nachrichten, die - je nach gewünschten Eigenschaften der Verbindung - optional gesendet werden können, sind mit einem Stern(*) gekennzeichnet.

%TODO:
% - Übersicht über den Handshake (auf Grafik eingehen)
% - Aushandeln der SecurityParameters (struct vorhanden)

\lstset{
	style=default,
	frame=single
}
\begin{figure}[H]
	\centering
	\begin{lstlisting}
§\textbf{Client}§                                               §\textbf{Server}§

                             <--------        HelloRequest*
ClientHello                  -------->
                                                ServerHello
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                         [ChangeCipherSpec]
                             <--------             Finished
Application Data             <------->     Application Data
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim vollständigen TLS-Handshake. Entnommen aus \cite{tls12}.}
	\label{fig_complete_handshake}
\end{figure}

\lstset{style=tls}

\subsection*{HelloRequest*}

\begin{lstlisting}
struct { } HelloRequest;
\end{lstlisting}

Diese Nachricht kann vom Server gesendet werden, wenn ein neuer Handshake gewünscht wird (beispielsweise um Schlüssel und kryptographische Funktionen während einer Verbindung neu auszuhandeln).

\subsection*{ClientHello}

\begin{lstlisting}
struct {
	ProtocolVersion client_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suites<2..2^16-2>;
	CompressionMethod compression_methods<1..2^8-1>;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ClientHello;
\end{lstlisting}

Hierbei enthält \datafield{client\_version} die neueste vom Client unterstützte TLS-/SSL-Version (z.B. 3.3 für TLS 1.2). 
\datafield{random} besteht aus einem 4-Byte großen Zeitstempel (UNIX-Format) und 28 zufälligen Bytes. 
Die \datafield{session\_id} dient zur Identifikation einer Sitzung. Sie ist bei dem ersten Handshake leer und kann später dazu verwendet werden, bestehende Sitzungen wieder aufzunehmen (vgl. Abschnitt \ref{sec_session_connection}). 
Die \ciphersuite{}-Liste enthält alle vom Client unterstützten \ciphersuites{} in Reihenfolge seiner Präferenz. 
Ebenso wird eine Liste von unterstützten Kompressionsalgorithmen übertragen. 
Optional kann auch eine Liste von gewünschten TLS-Extensions angegeben werden (vgl. refbla\todo{Abschnitt über TLS extensions vgl. TLS1.2 - 7.4.1.4}).

\subsection*{ServerHello}

\begin{lstlisting}
struct {
	ProtocolVersion server_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suite;
	CompressionMethod compression_method;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ServerHello;
\end{lstlisting}

In \datafield{server\_version} steht die höchste Version, die Server und Client unterstützen und die damit für die Kommunikation verwendet wird. \datafield{random} besteht äquivalent zur \clienthello{}-Nachricht aus einem 4-Byte Zeitstempel und 28 zufälligen Bytes. Die \datafield{session\_id} enthält entweder eine neu generierte ID, die ID einer wieder aufgenommen Sitzung oder kann auch leer sein, um anzugeben, dass die Sitzung nicht wieder aufgenommen werden kann. In \datafield{cipher\_suite} und \datafield{compression\_method} überträgt der Server die von ihm aus den vom Client übertragenen Listen ausgewählte \ciphersuite{} bzw. den Kompressionsalgorithmus. In der Extensionliste gibt der Server alle vom Client gewünschten Extensions an, die er unterstützt.

\subsection*{ServerCertificate*}

\begin{lstlisting}
struct {
	ASN.1Cert certificate_list<0..2^24-1>;
} Certificate;
\end{lstlisting}

In dieser Nachricht sendet der Server seine Zertifikatskette zur Überprüfung seiner Identität. Das erste Zertifikat in der Liste bildet das Serverzertifikat, folgende Zertifikate müssen das jeweils vorhergehende zertifizieren. Der im Zertifikat enthaltene Public Key muss zum ausgehandelten Schlüsselaustausch-Algorithmus passen. Wenn nicht anders ausgehandelt wird für die Zertifikate das X.509v3-Format verwendet.\todo{RFC als Quelle}

\subsection*{ServerKeyExchange*}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case dh_anon:
	      ServerDHParams params;
	  case dhe_dss:
	  case dhe_rsa:
	      ServerDHParams params;
	      digitally-signed struct {
	          opaque client_random[32];
	          opaque server_random[32];
	          ServerDHParams params;
	      } signed_params;
	  case rsa:
	  case dh_dss:
	  case dh_rsa:
	      struct {} ; /* message is omitted for rsa, dh_dss, and dh_rsa */
	};
} ServerKeyExchange;
\end{lstlisting}

Diese Nachricht wird nur für bestimmte Schlüsselaustausch-Algorithmen gesendet, wenn die \servercertificate{}-Nachricht nicht genügend Informationen zum Austausch des \premastersecret{} bietet (vgl. \clientkeyexchange{}-Nachricht).

\subsection*{CertificateRequest*}

\begin{lstlisting}
struct {
	ClientCertificateType certificate_types<1..2^8-1>;
	SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
	DistinguishedName certificate_authorities<0..2^16-1>;
} CertificateRequest;
\end{lstlisting}

TLS unterstützt optionale Clientauthentifizierung. Mit dieser Nachricht kann der Client vom Server aufgefordert werden ebenfalls ein Zertifikat zu senden. Die \datafield{certificate\_types}-Liste enthält alle Zertifikatarten (z.B. Zertifikat mit RSA-Schlüssel, ...), die vom Server unterstützt werden, und \datafield{supported\_signature\_algorithms} die unterstützten Signaturalgorithmen. In \datafield{certificate\_authorities} kann eine Liste von erwarteten CAs übertragen werden.

\subsection*{ServerHelloDone}

\begin{lstlisting}
struct { } ServerHelloDone;
\end{lstlisting}

Mit dieser Nachricht signalisiert der Server das Ende des \serverhello{} und zugehöriger Nachrichten.

\subsection*{ClientCertificate*}

Wenn von dem Server eine Clientauthentifizierung gefordert wurde, kann der Client in dieser Nachricht seine Zertifikatskette senden. Das Format entspricht dem der \servercertificate{}-Nachricht.

\subsection*{ClientKeyExchange}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case rsa:
	      EncryptedPreMasterSecret;
	  case dhe_dss:
	  case dhe_rsa:
	  case dh_dss:
	  case dh_rsa:
	  case dh_anon:
	      ClientDiffieHellmanPublic;
	} exchange_keys;
} ClientKeyExchange;
\end{lstlisting}

Wenn RSA als Schlüsselaustausch-Algorithmus vereinbart wurde, so wird das \premastersecret{} mit dem Public Key des Servers verschlüsselt und gesendet. Es besteht aus der größten vom Client unterstützten Protokollversion (2 Bytes), um Version-Rollback-Angriffe zu verhindern (siehe Abschnitt \ref{sec_version_rollback}), und 46 zufällig generierten Bytes.

\begin{lstlisting}
struct {
	public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;
\end{lstlisting}

Wenn der Schlüsselaustausch per Diffie-Hellman-Verfahren geschieht,...\todo{DH ergänzen, p.61}

\begin{lstlisting}
struct {
	select (PublicValueEncoding) {
	  case implicit: struct { };
	  case explicit: opaque dh_Yc<1..2^16-1>;
	} dh_public;
} ClientDiffieHellmanPublic;
\end{lstlisting}

\subsection*{CertificateVerify*}

\begin{lstlisting}
struct {
	digitally-signed struct {
	   opaque handshake_messages[handshake_messages_length];
	}
} CertificateVerify;
\end{lstlisting}

Diese Nachricht wird gesendet, falls ein Clientzertifikat vom Server angefordert wurde. Sie besteht aus einem mit dem Private Key des Clients signierten Hash der bisherigen Handshake-Nachrichten und dient dazu den Client zu authentifizieren.

\subsection*{ChangeCipherSpec}

Diese Nachricht gehört zum \changecipherspecprotocol{}. Es enthält lediglich diese eine Nachricht mit dem Wert 1. Das Empfangen signalisiert dem Empfänger, dass alle nachfolgend gesendeten Nachrichten mit den ausgehandelten kryptographischen Verfahren und Schlüsseln geschützt werden. Dazu werden read pending state (bei Empfang der Nachricht) und write pending state (nach Senden der Nachricht) in die current states kopiert.\todo{Irgendwo schon erwähnt oder bei der Einführung?}

\subsection*{Finished}

\begin{lstlisting}
struct {
	opaque verify_data[verify_data_length];
} Finished;
\end{lstlisting}

Die \finished{}-Nachricht dient zur Verifikation von erfolgreichem Schlüsselaustausch und Authentifikation. Diese Nachricht ist wie erwähnt die erste, die von den ausgehandelten Verfahren und Schlüsseln geschützt wird, daher kann hier überprüft werden, ob der Handshake erfolgreich verlaufen ist und beiden Kommunikationspartnern die gleichen Informationen vorliegen.

Die Nachricht besteht aus einem Hash über die bisher gesendeten bzw. empfangenen Nachrichten des \handshakeprotocol{}s zusammen mit dem \mastersecret{}:

\begin{lstlisting}
verify_data = PRF(master_secret, 
				  finished_label, 
				  Hash(handshake_messages)) [0..verify_data_length-1];
\end{lstlisting}

Das \datafield{finished\_label} wird durch \inquotes{client finished} auf der Client- bzw. \inquotes{server finished} auf der Serverseite gebildet. Der Hash wird durch die in der PseudoRandomFunction verwendete Hashfunktion berechnet. \todo{Irgendwo drauf eingehen} \datafield{verify\_data\_length} entspricht, wenn durch die \ciphersuite{} nicht anders vorgegeben, 12 Bytes Länge.

\section{Alert Protocol}

Das \alertprotocol{} dient dazu, auftretende Fehler zu versenden, die während der Kommunikation auftreten. Hierbei kann es sich zum Beispiel um fehlgeschlagene Überprüfung von entschlüsselten Nachrichten (\badrecordmac{}) oder fehlerhafte Zertifikatsüberprüfung (\badcertificate{}) handeln. Unterschieden wird zwischen Fehlern (fatal alert), die sofort zum Schließen der Sitzung führen, und Warnungen (warning alert). Eine Übersicht über alle Fehler findet sich in Abschnitt 7.2 von \cite{tls12}.

\section{Application Data Protocol}

Das \applicationdataprotocol{} ist zuständig für das Durchreichen von Anwendungsdaten, die von der Anwendungsschicht gesendet werden sollen. Die Daten werden durch das \recordprotocol{} übertragen und damit durch die während des Handshakes ausgehandelten Verfahren und Schlüssel geschützt.

\section{Sitzungs- und Verbindungskonzept}
\label{sec_session_connection}

\todo{Wo passt das Kapitel hier denn am Besten hin?}

TLS erstellt beim ersten Handshake eine Sitzung zwischen Client und Server. Hierbei wird ein Sitzungsidentifikator erstellt, der beim \serverhello{} mitgesendet wird. Weiterhin wird sich in der Sitzung das Zertifikat des Gegenübers, optional das Kompressionsverfahren, die \ciphersuite und das \mastersecret{} gemerkt.

Ein Client kann nun, wenn er den Sitzungsidentifikator beim \clienthello{} mitschickt, eine alte Sitzung in Form einer neuen Verbindung wiederaufnehmen oder mehrere Verbindungen parallel aufbauen. Eine Verbindung wird dabei durch Client- und Server-Zufallszahlen \(R_C\) und \(R_S\), die generierten Schlüssel, je nach verwendeten Verschlüsselungsverfahren einen Initialisierungsvektor, sowie aktuelle Sequenznummern beschrieben.

Beim Verbindungsaufbau kann so ein verkürzter Handshake genutzt werden, bei dem weniger Nachrichten gesendet werden müssen. Es kann dabei auf Neuberechnung des \mastersecret{}, Server- und Client-Validierung und Aushandlung der \ciphersuite{} verzichtet werden.

\lstset{
	style=default,
	frame=single
}
\begin{figure}[H]
	\centering
	\begin{lstlisting}
§\textbf{Client}§                                                §\textbf{Server}§

ClientHello                   -------->
                                                 ServerHello
                                          [ChangeCipherSpec]
                              <--------             Finished
[ChangeCipherSpec]
Finished                      -------->
Application Data              <------->     Application Data
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim abgekürzten TLS-Handshake. Entnommen aus \cite{tls12}.}
	\label{fig_abbreviated_handshake}
\end{figure}
\lstset{style=tls}


\section{\ciphersuites{}}

\section{Frühere SSL-/TLS-Versionen und TLS 1.3}


%---------------------------------------------------------------------------------------------------

%p. 18/p. 77
\begin{lstlisting}
struct {
	ConnectionEnd          entity;
	PRFAlgorithm           prf_algorithm;
	BulkCipherAlgorithm    bulk_cipher_algorithm;
	CipherType             cipher_type;
	uint8                  enc_key_length;
	uint8                  block_length;
	uint8                  fixed_iv_length;
	uint8                  record_iv_length;
	MACAlgorithm           mac_algorithm;
	uint8                  mac_length;
	uint8                  mac_key_length;
	CompressionMethod      compression_algorithm;
	opaque                 master_secret[48];
	opaque                 client_random[32];
	opaque                 server_random[32];
} §\textbf{SecurityParameters}§;
\end{lstlisting}

