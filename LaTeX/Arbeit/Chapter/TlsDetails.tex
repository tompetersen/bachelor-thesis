\lstdefinestyle{default}{
	numbers=none,
	frame=leftline,
	escapeinside={§}{§},
	emph={}
}

\lstdefinestyle{tls}{
	numbers=none,
	frame=none,%leftline,
	escapeinside={§}{§},
	emph={HelloRequest,ClientHello,ServerHello,Certificate,ServerKeyExchange,CertificateRequest,ServerHelloDone,ClientKeyExchange,CertificateVerify,ChangeCipherSpec,Finished,TLSCompressed,TLSCiphertext,TLSPlaintext,SecurityParameters},
	emphstyle=\textbf
}

\lstset{style=tls}

\chapter{Funktionsweise von TLS}

\label{sec_tls_overview}

SSL (Secure Socket Layer) bzw. TLS (Transport Layer Security) ist ein zustandsbehaftetes Protokoll, das auf dem TCP-Protokoll\footnote{
	Es existiert auch noch DTLS (Datagram Transport Layer Security), ein zu TLS ähnliches Protokoll, das auf UDP aufsetzt. Dieses Protokoll wird im Rahmen dieser Arbeit jedoch nicht weiter behandelt.
} der Transportschicht des ISO/OSI-Schichtenmodells aufbaut. 

Hauptaufgaben von TLS sind Authentifikation der Kommunikationspartner, Verschlüsselung der Kommunikation sowie die Sicherstellung der Integrität der übertragenen Nachrichten \cite{meyer14}. Dazu läuft die Kommunikation über TLS in zwei Phasen ab: Zu Beginn wird eine sichere Verbindung durch Festlegung der verwendeten kryptographischen Verfahren und des Schlüsselmaterials hergestellt. Danach können Daten transparent für Anwendungen und auf TLS aufbauende Protokolle über diese Verbindung gesendet werden.\\
Einige Beispiele für solche Protokolle und Anwendungen der Anwendungsschicht, die TLS nutzen, sind:
\begin{description}
\item[HTTPS] für die Datenübertragung, zumeist für die Auslieferung von Webseiten genutzt. 
\item[FTPS] für die Dateiübertragung.
\item[SMTP] für das Senden und Weiterleiten von E-Mails (als SMTPS oder per STARTTLS\footnote{\label{fn_starttls}
	SMTPS/IMAPS/POP3S beginnen die TLS-Verbindung bereits direkt nach dem Verbindungsaufbau und laufen über einen anderen Serverport, um dieses Verhalten zu erzwingen. STARTTLS ist ein Kommando, das nach Verbindungsaufbau gesendet werden kann, um eine TLS-Verbindung zu initiieren.}).
\item[IMAP] für den Zugriff auf E-Mails auf Mailservern (als IMAPS oder per STARTTLS\textsuperscript{\ref{fn_starttls}}).
\item[POP3] für den Abruf von E-Mails von Mailservern (als POP3S oder per STARTTLS\textsuperscript{\ref{fn_starttls}}).
\item[OpenVPN,] eine verbreitete VPN-Software.
\end{description}

SSL wurde von der Firma Netscape entwickelt und zuerst in ihrem Browser, dem Netscape Navigator, verwendet. Nach mehreren neuen Protokollversionen und nachdem es starke Verbreitung gefunden hatte, wurde es durch die IETF als TLS 1.0 standardisiert (TLS 1.0 entspricht SSL 3.1). Aktuell ist die TLS-Version 1.2 und an Version 1.3 wird gearbeitet\footnote{
	Im weiteren Verlauf dieser Arbeit wird der Einfachheit halber lediglich von TLS gesprochen. Bei etwaigen Unterschieden zwischen den Protokollversionen wird explizit auf diese eingegangen.
}.\\
Inzwischen ist TLS das \inquotes{gegenwärtig meistverwendete Verschlüsselungsprotokoll im Internet}\cite{schmeh09}. Gründe hierfür sind dem Autor zufolge insbesondere die leichte Integrierbarkeit in bestehende Strukturen, die \inquotes{[im Gegensatz zu IPSec] deutlich schnörkelloser[e] und einfacher[e]} Protokollspezifikation und auch die marktreife Verfügbarkeit in den frühen 90er Jahren.

\section{Funktionsweise und Teilprotokolle}

Die Informationen in diesem Abschnitt stammen überwiegend aus der TLS 1.2-Spezifikation \cite{tls12}. Für einen ersten Überblick wurde \cite{eckert13} genutzt.
\todo{Zum Einstieg grobe Funktionsbeschreibung, evtl. schon mit Grafik über Verbindungsaufbau?, Grafik der TLS-Protokolle}

TLS besteht aus zwei Schichten. In der oberen Schicht sind vier Teilprotokolle spezifiziert: das \handshakeprotocol{}, das zum Aushandeln von kryptographischen Algorithmen und zur Vereinbarung von Schlüsselmaterial dient, das \changecipherspecprotocol{}, das den Beginn der Nutzung dieser Algorithmen regelt, das \alertprotocol{}, das das Versenden von Fehlerinformationen in der Verbindung übernimmt und das \applicationdataprotocol{}, das für den Austausch von Anwendungsdaten genutzt wird. Auf diese Protokolle soll später eingegangen werden.\\ 
In der unteren Schicht befindet sich das \recordprotocol{}, das die Daten von den Teilprotokollen der oberen Schicht entgegennimmt, verarbeitet und dann an tiefere Netzwerkschichten weitergibt. Eine Übersicht über diese Schichten bietet Abbildung \ref{fig_tls_protocol_hierarchie}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=0cm,outer sep = 0pt]
		\tikzstyle{protocol}=[draw, rectangle, minimum height=1cm, minimum width=4cm, fill=blue!15, anchor=south west]
		\tikzstyle{row}=[draw, rectangle, minimum height=1cm, minimum width=16cm, anchor=south west]

		\node[protocol] (handshake) at (0,2) {Handshake};
		\node[protocol] (change) [right = of handshake] {Change Cipher Spec};
		\node[protocol] (alert) [right = of change] {Alert};
		\node[protocol] (application) [right = of alert] {Application Data};

		\node[row, fill=gray!20,] (record) at (0,1) {Record Protocol};
		\node[row] (tcp) at (0,0) {TCP};
	\end{tikzpicture}
	\caption{Überblick über die TLS-Protokollhierarchie}
	\label{fig_tls_protocol_hierarchie}
\end{figure}

\section{Record Protocol}
\todo{Kapitel evtl. hinter den Handshake? Und vorher auf Schlüsselberechnung eingehen?}
Die zu sendenden Protokolldaten werden von dem \recordprotocol{} in maximal \(2^{14}\) Byte große Pakete fragmentiert und optional komprimiert. Danach wird je nach während des Handshakes verhandelten kryptographischen Funktionen (vgl. Abschnitt \ref{sec_tls_handshake}) die Integrität der Daten durch Berechnen und Anhängen eines MACs gesichert und die Nachricht danach zusammen mit dem MAC verschlüsselt\footnote{
	Diese Reihenfolge der Operationen wird MAC-then-Encrypt genannt.
	Laut \cite{AE2000} ist Encrypt-then-MAC vorzuziehen.
	In \cite{krawczyk01} wird dieses Ergebnis bestätigt, aber auch die Sicherheit von MAC-then-Encrypt unter bestimmten Voraussetzungen gezeigt.\\
	In \cite{ferguson10} fügen die Autoren hinzu, dass das Erkennen und Verwerfen ungültiger Nachrichten durch Encrypt-then-MAC vereinfacht wird. Auf der anderen Seite erwähnen sie aber auch Vorteile der MAC-then-Encrypt-Reihenfolge: Die Ein- und Ausgabe der MAC-Funktion sind einem Angreifer verborgen, so dass Angriffe gegen den MAC erschwert werden und die Integrität der Nachricht damit besser geschützt ist. Außerdem führen sie das Horton-Prinzip an (siehe \cite{wagner96}), wonach eine Authentifikation dessen, was gemeint ist und nicht was gesagt wird, stattfinden sollte. %\inquotes{Authenticate what is meant, not what is said}
	Bei der Erstellung eines Systems muss also abgewogen werden, welche Methode genutzt werden sollte.
}. Auf diese Schritte wird im Folgenden genauer eingegangen.

Daten, die von einer höheren Schicht entgegengenommen werden, werden zu Beginn in ein \datafield{TLSPlaintext}-Objekt verpackt. 

\begin{lstlisting}
 struct {
	ContentType type;  
	ProtocolVersion version; 
	uint16 length;
	opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
\end{lstlisting}

%enum { //eher erklaeren als uebernehmen
%	change_cipher_spec(20), alert(21), handshake(22), application_data(23),(255)
%} ContentType;
%
%struct { //eher erklaeren als uebernehmen
%	uint8 major;
%	uint8 minor;
%} ProtocolVersion;

Der \datafield{Contenttype} steht für den Protokolltyp der Nachricht: \changecipherspecprotocol{} (20), \alertprotocol{} (21), \handshakeprotocol{} (22) oder \applicationdataprotocol{} (23). Die \datafield{ProtocolVersion} besteht aus zwei Bytes für die über- und untergeordnete Protokollnummer (z.B. (3,3) für TLS 1.2). Im \datafield{fragment} werden die zu übertragenden Daten gespeichert.

Danach werden die Daten optional durch den während des Handshakes vereinbarten Kompressionsalgorithmus komprimiert und in ein \datafield{TLSCompressed}-Objekt überführt.

\begin{lstlisting}
 struct {
	ContentType type;       /* same as TLSPlaintext.type */
	ProtocolVersion version;/* same as TLSPlaintext.version */
	uint16 length;
	opaque fragment[TLSCompressed.length];
} TLSCompressed;
\end{lstlisting}

Anschließend wird die Integrität der Daten bei Nutzung einer \ciphersuite{} mit Strom- oder Blockverschlüsselungsalgorithmus (vgl. Abschnitt \ref{sec_cipher_suites}) mit einem MAC geschützt, der folgendermaßen berechnet wird:
\begin{lstlisting}
MAC(MAC_write_key, seq_num +
				   TLSCompressed.type +
				   TLSCompressed.version +
				   TLSCompressed.length +
				   TLSCompressed.fragment);
\end{lstlisting}
Die jeweils für jeden Kommunikationspartner unabhängig fortlaufende Sequenznummer \datafield{seq\_num} dient hierbei zur Verhinderung von Replay-Angriffen, also der erneuten Sendung von mitgelesenen Paketen durch einen Angreifer. Auf die Berechnung von \datafield{MAC\_write\_key} wird in Abschnitt \ref{sec_key_material} eingegangen.\\
Bei den in TLS verwendeten \ciphersuites{} wird das HMAC-Verfahren zur Berechnung des MACs genutzt. Details zu diesem Verfahren sind in \cite{hmac97} zu finden. Die hierbei verwendete Hashfunktion wird in der \ciphersuite{} angegeben. 

Danach wird das \datafield{TLSCompressed}-Objeckt in ein \datafield{TLSCiphertext}-Objekt überführt und dann versendet.

%p.21
\begin{lstlisting}
struct {
	ContentType type;       /* same as TLSCompressed.type */
	ProtocolVersion version;/* same as TLSCompressed.version */
	uint16 length;
	select (SecurityParameters.cipher_type) {
	    case stream: GenericStreamCipher;
	    case block:  GenericBlockCipher;
	    case aead:   GenericAEADCipher;
	} fragment;
} TLSCiphertext;
\end{lstlisting}

Abhängig vom verwendeten Verschlüsselungsverfahren sehen diese Nachrichten unterschiedlich aus. Abbildung \ref{fig_tls_cipher_types} bietet einen Überblick über diese verschiedenen Nachrichten. Dabei sind die fett umrahmten Felder diejenigen, die mit dem jeweiligen Algorithmus verschlüsselt werden.

Bei Stromchiffren wird der MAC zusammen mit den Daten (\datafield{TLSCompressed.fragment}) verschlüsselt und übertragen. 

Bei Blockchiffren werden die Daten zusammen mit dem MAC zuerst mit Padding versehen, um ein Vielfaches der Blocklänge als Nachrichtenlänge zu erhalten, wobei jedes Padding-Byte die Paddinglänge als Wert enthält und die Länge zusätzlich als Byte an die Nachricht angehängt wird. Folglich gilt:
\( |\text{daten}| + |\text{mac}| + |\text{padding}| + 1 = k * \text{blocklänge}, k \in \mathbb{N}\).\\
Für Blockchiffren im CBC-Modus wird ein IV benötigt (siehe Abschnitt \ref{sec_block_cipher}). Dieser wird für jede Nachricht zufällig generiert. Dann werden Daten, MAC, Padding und Paddinglänge zusammen verschlüsselt und mit dem IV versendet.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=0cm, outer sep = 0pt]
		\tikzstyle{protocol} =		[draw, rectangle, minimum height=1.2cm, minimum width=2cm, fill=gray!20, align = center, anchor=south west]
		\tikzstyle{tlsmessage} = 	[draw, rectangle, minimum height=1.2cm, minimum width=2cm, fill=blue!15, align = center, anchor=south west, double=black, double distance=1pt]
		\tikzstyle{fragment_enc} = 	[draw, rectangle, minimum height=1.2cm, minimum width=2cm, fill=orange!30, align = center, anchor=south west, double=black, double distance=1pt]
		\tikzstyle{fragment} = 		[draw, rectangle, minimum height=1.2cm, minimum width=2cm, fill=orange!30, align = center, anchor=south west]
		\tikzstyle{titlebox} = 		[draw = white, rectangle, minimum width=2cm, align = center, anchor=south west]

		\node[protocol] (type1) at (0,6) {type\\1 Byte};
		\node[protocol] (version1) [right = of type1] {version\\2 Byte};
		\node[protocol] (length1) [right = of version1] {length\\2 Byte};
		\node[tlsmessage] (content1) [right = of length1] {content\\TLSMessage};
		\node[fragment_enc] (mac1) [right = of content1] {MAC\\};

		\node[titlebox] (title1) at (0,5) {TLSCiphertext mit GenericStreamCipher-fragment};

		\node[protocol] (type2) at (0,3.5) {type \\ 1 Byte};
		\node[protocol] (version2) [right = of type2] {version\\2 Byte};
		\node[protocol] (length2) [right = of version2] {length\\2 Byte};
		\node[fragment] (iv2) [right = of length2] {IV\\};
		\node[tlsmessage] (content2) [right = of iv2] {content\\TLSMessage};
		\node[fragment_enc] (mac2) [right = of content2] {MAC\\};
		\node[fragment_enc] (pad2) [right = of mac2] {padding\\};
		\node[fragment_enc] (padlength2) [right = of pad2] {padding\_length\\ 1 Byte};

		\node[titlebox] (title2) at (0,2.5) {TLSCiphertext mit GenericBlockCipher-fragment};

		\node[protocol] (type3) at (0,1) {type \\ 1 Byte};
		\node[protocol] (version3) [right = of type3] {version\\2 Byte};
		\node[protocol] (length3) [right = of version3] {length\\2 Byte};
		\node[fragment] (nonce3) [right = of length3] {nonce\_explicit\\};
		\node[tlsmessage] (content3) [right = of nonce3] {content\\TLSMessage};

		\node[titlebox] (title3) at (0,0) {TLSCiphertext mit GenericAEADCipher-fragment};
	\end{tikzpicture}
	\caption{TLSCiphertext mit verschiedenen Chiffrearten}
	\label{fig_tls_cipher_types}
\end{figure}

% For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), p. 24  
Bei der Nutzung von AEAD-Chiffren werden bei der Verschlüsselung zusätzlich zum Klartext und Schlüssel zwei zusätzliche Parameter verwendet: ein sogenanntes Nonce (eine einmalig verwendete, zufällige Eingabe) und zusätzliche Daten, in die die Sequenznummer der Nachricht, ihr Typ, ihre Version und ihre Länge einfließen (ähnlich zur Berechnung des MACs). Der explizite Teil des Nonce wird neben den verschlüsselten Daten übertragen. Der implizite Teil wird durch \datafield{server write IV} bzw. \datafield{client write IV} gebildet (vgl. Abschnitt \ref{sec_key_material}). Die Notwendigkeit einer MAC-Berechnung entfällt bei diesem Verfahren.

\section{Berechnung des Schlüsselmaterials}
\label{sec_key_material}

Bei der Berechnung von Schlüsseln verwendet TLS eine eigene Konstruktion einer Pseudo Random Function (PRF), die standardmäßig für alle \ciphersuites{} verwendet wird und auf dem HMAC-Verfahren aufbaut:

\begin{lstlisting}
PRF(secret, label, seed) = P_hash(secret, label + seed)

P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
					   HMAC_hash(secret, A(2) + seed) +
					   HMAC_hash(secret, A(3) + seed) + ...
			mit A(0) = seed
				A(i) = HMAC_hash(secret, A(i-1))
\end{lstlisting}

Aus \datafield{secret}, \datafield{label} und \datafield{seed} können so beliebige Mengen von pseudozufälligen Bits generiert werden (sieht man einmal von der Periode der Funktion ab).

Nach der \clientkeyexchange{}-Nachricht sind Client und Server im Besitz des \premastersecret{}. Aus diesem und den in den Hello-Nachrichten übertragenen Zufallswerten (vgl. Abschnitte \ref{sec_handshake_client_hello} und \ref{sec_handshake_server_hello}) wird nun auf beiden Seiten das \mastersecret{} folgendermaßen generiert:

\begin{lstlisting}
master_secret = PRF(pre_master_secret, 
					"master secret",
					ClientHello.random + ServerHello.random)[0..47];
\end{lstlisting}

Aus diesem \mastersecret{} werden je nach verwendeten kryptographischen Verfahren Schlüssel für die Erstellung des MACs, für die Verschlüsselung zwischen Client und Server und für den impliziten Teil des Nonce bei AEAD-Chiffren berechnet:
\begin{lstlisting}
client write MAC key
server write MAC key
client write encryption key
server write encryption key
client write IV
server write IV
\end{lstlisting}

Dazu werden solange Schlüsselblöcke nach dem folgenden Verfahren erstellt, bis genug Daten vorhanden sind, um alle benötigten Schlüssel konstruieren zu können: 

\begin{lstlisting}
key_block = PRF(SecurityParameters.master_secret,
                "key expansion",
                SecurityParameters.server_random +
                SecurityParameters.client_random);
\end{lstlisting}


\section{TLS-Handshake}

\label{sec_tls_handshake}

Das \handshakeprotocol{} dient zur Herstellung einer gesicherten Verbindung. Hierbei werden verwendete TLS-Version und kryptographische Verfahren zwischen den Kommunikationspartnern vereinbart, optional ihre Identitäten authentifiziert und ein gemeinsames Geheimnis (das sogenannte \premastersecret{}) für die bereits beschriebene Generierung der während der eigentlichen Kommunikation verwendeten Schlüssel übertragen oder berechnet. 

%TODO:
% - Übersicht über den Handshake (auf Grafik eingehen)
% - Aushandeln der SecurityParameters (struct vorhanden)

\lstset{
	style=default,
	frame=single
}
\begin{figure}[H]
	\centering
	\begin{lstlisting}
§\textbf{Client}§                                               §\textbf{Server}§

                             <--------        HelloRequest*
ClientHello                  -------->
                                                ServerHello
                                         ClientCertificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             <--------      ServerHelloDone
ServerCertificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                         [ChangeCipherSpec]
                             <--------             Finished
[Application Data]           <------->   [Application Data]
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim vollständigen TLS-Handshake. Entnommen aus \cite{tls12} und angepasst.}
	\label{fig_complete_handshake}
\end{figure}
\lstset{style=tls}

Eine Übersicht über die während eines vollständigen Handshakes ausgetauschten Nachrichten bietet Abbildung \ref{fig_complete_handshake}. Nachrichten, die - je nach gewünschten Eigenschaften der Verbindung - optional gesendet werden können, sind mit einem Stern (*) gekennzeichnet. Da die \changecipherspec{}- und \applicationdata{}-Nachrichten einem eigenen Teilprotokoll entstammen, sind sie mit eckigen Klammern gekennzeichnet. Im Folgenden werden die Handshake-Nachrichten und ihr Aufbau nun im Detail betrachtet.

\subsection{HelloRequest*}

\begin{lstlisting}
struct { } HelloRequest;
\end{lstlisting}

Diese Nachricht kann vom Server gesendet werden, wenn während einer bestehenden Verbindung ein neuer Handshake gewünscht wird. Dies kann beispielsweise dazu dienen Schlüssel für eine länger bestehende TLS-Verbindung nach einer gewissen Zeit neu auszuhandeln.

\subsection{ClientHello}
\label{sec_handshake_client_hello}

\begin{lstlisting}
struct {
	ProtocolVersion client_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suites<2..2^16-2>;
	CompressionMethod compression_methods<1..2^8-1>;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ClientHello;
\end{lstlisting}

Mit der \clienthello{}-Nachricht initiiert der Client einen Verbindungsaufbau und sendet von ihm unterstützte Verfahren, die in der Verbindung genutzt werden können, sowie eine Identifikationsnummer für die Sitzung und einen Zufallswert.

Hierbei enthält \datafield{client\_version} die neueste vom Client unterstützte TLS-/SSL-Version. 
\datafield{random} besteht aus einem 4-Byte großen Zeitstempel (UNIX-Format) und 28 zufälligen Bytes. 
Die \datafield{session\_id} dient zur Identifikation einer Sitzung. Sie ist bei dem ersten Handshake leer und kann später dazu verwendet werden, bestehende Sitzungen wieder aufzunehmen (vgl. Abschnitt \ref{sec_session_connection}). 
Die \ciphersuite{}-Liste enthält alle vom Client unterstützten \ciphersuites{} geordnet nach Präferenz. 
Ebenso wird eine Liste von unterstützten Kompressionsalgorithmen übertragen. 
Optional kann auch eine Liste von gewünschten TLS-Extensions angegeben werden (vgl. Abschnitt \ref{sec_tls_extensions}).

\subsection{ServerHello}
\label{sec_handshake_server_hello}

\begin{lstlisting}
struct {
	ProtocolVersion server_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suite;
	CompressionMethod compression_method;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ServerHello;
\end{lstlisting}

In der \serverhello{}-Nachricht teilt der Server dem Client die (aus den in der \clienthello{}-Nachricht übertragenen) ausgewählten Verfahren mit und sendet die Identifikationsnummer sowie seinen Zufallswert.

In \datafield{server\_version} steckt die höchste Version, die Server und Client unterstützen und die damit für die Kommunikation verwendet wird. \datafield{random} besteht äquivalent zur \clienthello{}-Nachricht aus einem 4-Byte Zeitstempel und 28 zufälligen Bytes, die vom Server berechnet wurden. Die \datafield{session\_id} enthält entweder eine neu generierte Identifikationsnummer, die Identifikationsnummer einer wieder aufgenommen Sitzung oder kann auch leer sein, um anzugeben, dass die Sitzung nicht wieder aufgenommen werden kann. In \datafield{cipher\_suite} und \datafield{compression\_method} überträgt der Server die von ihm aus den vom Client übertragenen Listen ausgewählte \ciphersuite{} bzw. den Kompressionsalgorithmus. In der Extensionliste gibt der Server alle vom Client gewünschten Extensions an, die er unterstützt.

\subsection{ServerCertificate*}

\begin{lstlisting}
struct {
	ASN.1Cert certificate_list<0..2^24-1>;
} Certificate;
\end{lstlisting}

In dieser Nachricht sendet der Server seine Zertifikatskette zur Überprüfung seiner Identität. Das erste Zertifikat in der Liste bildet das Serverzertifikat, folgende Zertifikate müssen das jeweils vorhergehende zertifizieren. Der im Zertifikat enthaltene öffentliche Schlüssel muss zum ausgehandelten Schlüsselaustausch-Algorithmus passen. Wenn nicht anders vereinbart, wird für die Zertifikate das X.509v3-Format\footnote{Ein Standard für Public-Key-Infrastrukturen, spezifiziert in RFC 5280.} verwendet.

\subsection{ServerKeyExchange*}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case dh_anon:
	      ServerDHParams params;
	  case dhe_dss:
	  case dhe_rsa:
	      ServerDHParams params;
	      digitally-signed struct {
	          opaque client_random[32];
	          opaque server_random[32];
	          ServerDHParams params;
	      } signed_params;
	  case rsa:
	  case dh_dss:
	  case dh_rsa:
	      struct {} ; /* message is omitted for rsa, dh_dss, and dh_rsa */
	};
} ServerKeyExchange;
\end{lstlisting}

Diese Nachricht wird nur für bestimmte Schlüsselaustausch-Verfahren gesendet, wenn die \servercertificate{}-Nachricht nicht genügend Informationen zum Austausch des \premastersecret{} bietet (vgl. \clientkeyexchange{}-Nachricht).

\datafield{ServerDHParams} enthält dabei die öffentlichen Diffie-Hellman-Parameter \(p\) (die prime Ordnung der gewählten Gruppe), \(g\) (einen Erzeuger der Gruppe) und den öffentlichen Schlüssel \(Y_s = g^{X_s} \mod{p}\), wobei \(X_s\) für den geheimen Schlüssel des Servers steht.

Im Fall eines nicht anonymen Diffie-Hellman-Schlüsselaustauschs werden diese Parameter mit gewähltem asymmetrischen Verfahren (DSS oder RSA) und dem zum öffentlichen Schlüssel aus der \servercertificate{}-Nachricht gehörigen geheimen Schlüssel signiert.

\subsection{CertificateRequest*}

\begin{lstlisting}
struct {
	ClientCertificateType certificate_types<1..2^8-1>;
	SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
	DistinguishedName certificate_authorities<0..2^16-1>;
} CertificateRequest;
\end{lstlisting}

TLS unterstützt eine optionale Clientauthentifizierung. Mit dieser Nachricht kann der Client vom Server aufgefordert werden ebenfalls ein Zertifikat zu senden. Die \datafield{certificate\_types}-Liste enthält alle Zertifikatarten (z.B. Zertifikat mit RSA-Schlüssel, ...), die vom Server unterstützt werden, und \datafield{supported\_signature\_algorithms} die unterstützten Signaturalgorithmen. In \datafield{certificate\_authorities} kann eine Liste von erwarteten CAs übertragen werden.

\subsection{ServerHelloDone}

\begin{lstlisting}
struct { } ServerHelloDone;
\end{lstlisting}

Mit dieser Nachricht signalisiert der Server das Ende des \serverhello{} und zugehöriger Nachrichten.

\subsection{ClientCertificate*}

Wenn von dem Server eine Clientauthentifizierung gefordert wurde, kann der Client in dieser Nachricht seine Zertifikatskette senden. Das Format entspricht dem der \servercertificate{}-Nachricht.

\subsection{ClientKeyExchange}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case rsa:
	      EncryptedPreMasterSecret;
	  case dhe_dss:
	  case dhe_rsa:
	  case dh_dss:
	  case dh_rsa:
	  case dh_anon:
	      ClientDiffieHellmanPublic;
	} exchange_keys;
} ClientKeyExchange;
\end{lstlisting}

Wenn RSA als Schlüsselaustausch-Algorithmus vereinbart wurde, so wird das vom Client generierte \premastersecret{} mit dem (aus dem Serverzertifikat stammenden) öffentlichen Schlüssel des Servers verschlüsselt und gesendet. Es besteht aus der größten vom Client unterstützten Protokollversion (2 Bytes), um Version-Rollback-Angriffe zu verhindern (siehe Abschnitt \ref{sec_version_rollback}), und 46 zufällig generierten Bytes.

\begin{lstlisting}
struct {
	public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;
\end{lstlisting}

Wenn der Schlüsselaustausch per Diffie-Hellman-Verfahren geschieht und der öffentliche Schlüssel des Clients nicht in seinem optional in der \clientcertificate{}-Nachricht gesendeten Zertifikat enthalten ist, sendet er in dieser Nachricht seinen öffentlichen DH-Schlüssel \(Y_c = g^{X_c} \mod{p}\).

\begin{lstlisting}
struct {
	select (PublicValueEncoding) {
	  case implicit: struct { };
	  case explicit: opaque dh_Yc<1..2^16-1>;
	} dh_public;
} ClientDiffieHellmanPublic;
\end{lstlisting}

Das \premastersecret{} wird dann als \(Z=(Y_c)^{X_s} \mod{p}\) auf der Serverseite bzw. \(Z=(Y_s)^{X_c} \mod{p}\) auf der Clientseite berechnet.

\subsection{CertificateVerify*}

\begin{lstlisting}
struct {
	digitally-signed struct {
	   opaque handshake_messages[handshake_messages_length];
	}
} CertificateVerify;
\end{lstlisting}

Diese Nachricht wird gesendet, falls ein Clientzertifikat vom Server angefordert wurde. Sie besteht aus einem mit dem geheimen Schlüssel des Clients signierten Hash der bisherigen Handshake-Nachrichten und dient zur Authentifikation des Clients.

\subsection{ChangeCipherSpec}

Diese Nachricht gehört zum \changecipherspecprotocol{}. Es enthält lediglich diese eine Nachricht mit dem Wert 1. Das Empfangen signalisiert dem Empfänger, dass alle nachfolgend gesendeten Nachrichten mit den ausgehandelten kryptographischen Verfahren und Schlüsseln geschützt werden. Dazu werden read pending state (bei Empfang der Nachricht) und write pending state (nach Senden der Nachricht) in die current states kopiert.\todo{Irgendwo schon erwähnt oder bei der Einführung? EIGENE section für ChangeCipherSpec und current/pending states}

\subsection{Finished}

\begin{lstlisting}
struct {
	opaque verify_data[verify_data_length];
} Finished;
\end{lstlisting}

Die \finished{}-Nachricht dient zur Verifikation von erfolgreichem Schlüsselaustausch und Authentifikation. Diese Nachricht ist wie erwähnt die erste, die von den ausgehandelten Verfahren und Schlüsseln geschützt wird. Daher kann hier überprüft werden, ob der Handshake erfolgreich verlaufen ist und beiden Kommunikationspartnern die gleichen Informationen vorliegen.

Die Nachricht besteht aus einem Hash über die bisher gesendeten bzw. empfangenen Nachrichten des \handshakeprotocol{}s zusammen mit dem \mastersecret{}:

\begin{lstlisting}
verify_data = PRF(master_secret, 
				  finished_label, 
				  Hash(handshake_messages)) [0..verify_data_length-1];
\end{lstlisting}

Das \datafield{finished\_label} wird durch \inquotes{client finished} auf der Client- bzw. \inquotes{server finished} auf der Serverseite gebildet. Der Hash wird durch die in der PRF verwendete Hashfunktion berechnet (vgl. Abschnitt \ref{sec_key_material}).  \datafield{verify\_data\_length} entspricht, wenn durch die \ciphersuite{} nicht anders vorgegeben, 12 Bytes Länge.

Nachdem \datafield{verify\_data} vom Server und Client jeweils mit dem für die Gegenseite berechneten Wert verglichen wurde, ist die Verbindung im Erfolgsfall aufgebaut. 

Nun sind die \datafield{SecurityParameters} vereinbart und bilden zusammen mit den berechneten Schlüsseln (vgl. Abschnitt \ref{sec_key_material}) den Verbindungszustand. 
%p. 18/p. 77
\begin{lstlisting}
struct {
	ConnectionEnd          entity;
	PRFAlgorithm           prf_algorithm;
	BulkCipherAlgorithm    bulk_cipher_algorithm;
	CipherType             cipher_type;
	uint8                  enc_key_length;
	uint8                  block_length;
	uint8                  fixed_iv_length;
	uint8                  record_iv_length;
	MACAlgorithm           mac_algorithm;
	uint8                  mac_length;
	uint8                  mac_key_length;
	CompressionMethod      compression_algorithm;
	opaque                 master_secret[48];
	opaque                 client_random[32];
	opaque                 server_random[32];
} SecurityParameters;
\end{lstlisting}
Diese Informationen enthalten Angaben zu verwendeter \ciphersuite{}, zum Kompressionsalgorithmus und das \mastersecret{}. Sie werden vom \recordprotocol{} für die Verschlüsselung und Authentifizierung von Nachrichten verwendet.

\section{Alert Protocol}

Das \alertprotocol{} dient dazu, Fehler zu versenden, die während der Kommunikation auftreten. Hierbei kann es sich zum Beispiel um fehlgeschlagene Überprüfung von entschlüsselten Nachrichten (\badrecordmac{}) oder fehlerhafte Zertifikatsüberprüfung (\badcertificate{}) handeln. Unterschieden wird zwischen Fehlern (fatal alert), die sofort zum Schließen der Sitzung führen, und Warnungen (warning alert). Eine Übersicht über alle Fehler findet sich in Abschnitt 7.2 von \cite{tls12}.

\section{Application Data Protocol}

Das \applicationdataprotocol{} ist zuständig für das Durchreichen von Anwendungsdaten, die von der Anwendungsschicht gesendet werden sollen. Die Daten werden durch das \recordprotocol{} übertragen und damit durch die während des Handshakes ausgehandelten Verfahren geschützt.

\section{Sitzungen, Verbindungen und der verkürzte Handshake}
\label{sec_session_connection}

\todo{Wo passt das Kapitel hier denn am Besten hin?}

TLS erstellt beim ersten Handshake eine Sitzung zwischen Client und Server. Hierbei wird ein Sitzungsidentifikator gewählt, der beim \serverhello{} mitgesendet wird. 

Ein Client kann nun später, wenn er den erhaltenen Sitzungsidentifikator in einer \clienthello{}-Nachricht mitschickt, eine alte Sitzung in Form einer neuen Verbindung wiederaufnehmen oder mehrere Verbindungen parallel aufbauen. Dabei werden die in den \datafield{SecurityParameters} hinterlegten Verfahren genutzt und aus dem ebenfalls hinterlegten \mastersecret{} sowie den in den Hello-Nachrichten übertragenen random-Werten neue Schlüssel berechnet (siehe Abschnitt \ref{sec_key_material}). Dadurch kommt der verkürzte Handshake mit weniger gesendeten Nachrichten aus, als ein neuer Handshake, wie in Abbildung \ref{fig_abbreviated_handshake} ersichtlich ist. So kann auf Neuberechnung des \mastersecret{}, Server- und Client-Validierung und Aushandlung der \ciphersuite{} verzichtet werden. Durch die \finished{}-Nachricht können sich Client und Server durch das gleiche Schlüsselmaterial, das auf dem \mastersecret{} beruht, trotzdem sicher sein, mit dem optional authentifizierten Gegenüber zu kommunizieren.

\lstset{
	style=default,
	frame=single
}
\begin{figure}[H]
	\centering
	\begin{lstlisting}
§\textbf{Client}§                                                §\textbf{Server}§

ClientHello                   -------->
                                                 ServerHello
                                          [ChangeCipherSpec]
                              <--------             Finished
[ChangeCipherSpec]
Finished                      -------->
Application Data              <------->     Application Data
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim abgekürzten TLS-Handshake. Entnommen aus \cite{tls12}.}
	\label{fig_abbreviated_handshake}
\end{figure}
\lstset{style=tls}


\section{\ciphersuites{}}
\label{sec_cipher_suites}

Eine \ciphersuite{} legt fest, welche Algorithmen zum Schlüsselaustausch, zur Verschlüsselung und zur Berechnung des MACs verwendet werden und welche Eigenschaften (Schlüssellänge, Blocklänge, ...) diese besitzen. In der TLS 1.2-Spezifikation (\cite{tls12}) sind 37 \ciphersuites{} festgelegt.

Zum Schlüsselaustausch stehen \monospace{RSA} sowie verschiedene Varianten\footnote{
	\monospace{DH}: Zertifikat mit festen Diffie-Hellman-Parametern\\ 
	\monospace{DHE}: Temporäre Generierung von DH-Parametern für jede Sitzung \\
	\monospace{DH\_anon}:  Nicht-authentifizierte DH-Parameter
} des Diffie-Hellman-Verfahrens zur Verfügung. 
Zur Verschlüsselung sind die Stromchiffre \monospace{RC4\_128} sowie die Blockchiffren \monospace{3DES\_EDE\_CBC}, \monospace{AES\_128\_CBC} und \monospace{AES\_256\_CBC} festgelegt. 
Zur Berechnung des MACs können \monospace{MD5}, \monospace{SHA1} und \monospace{SHA256} verwendet werden (jeweils wie erwähnt unter Nutzung von HMAC).

Laut Spezifikation muss zumindest \monospace{TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA} von jeder konformen Implementation angeboten werden.

Einen Sonderfall bildet die \ciphersuite{} \monospace{TLS\_NULL\_WITH\_NULL\_NULL}, die vor der Festlegung der \ciphersuite{} während des Handshakes als Standard festgelegt ist und weder Verschlüsselung noch MAC bietet.

Kurz sei hier auch noch erwähnt, dass frühere Versionen (bis TLS 1.1) aufgrund von gesetzlichen Vorschriften zum Export von Kryptographie aus den USA \ciphersuites{} enthielten, die durch Nutzung kürzerer Schlüssel leichter zu brechen sein sollten (so genannte export-geschwächte \ciphersuites{}). Diese teilweise noch unterstützten Verfahren ermöglichen noch heute Angriffe auf SSL/TLS (z.B. der FREAK-Angriff in Abschnitt \ref{sec_attack_freak}).

\section{TLS-Extensions}

\label{sec_tls_extensions}

TLS-Extensions werden dazu genutzt, das Protokoll um zusätzliche Funktionalität zu erweitern. Das Konzept wurde parallel zu TLS entwickelt und mit TLS 1.2 in den Standard aufgenommen.

In der \clienthello{}- und \serverhello{}-Nachricht können sich die Kommunikationspartner auf Extensions einigen, die von beiden Seiten unterstützt werden und im Verlauf der Sitzung genutzt werden können. Jeder Extension-Eintrag wird dabei durch ihren Typ und Extension-spezifische Daten gebildet. 
\begin{lstlisting}
struct {
	ExtensionType extension_type;
	opaque extension_data<0..2^16-1>;
} Extension;
\end{lstlisting}

Beispiele für solche Extensions sind Server Name Indication, die es einem Server erlaubt abhängig vom geforderten Host verschiedene Zertifikate auszuliefern, oder Encrypt-then-MAC, die es erlaubt, die Reihenfolge von Verschlüsselung und Authentifizierung einer Nachricht im \recordprotocol{} zu tauschen. Eine aktuelle Liste registrierter TLS-Extensions wird durch die IANA (Internet Assigned Numbers Authority) bereitgestellt\footnote{http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml}.

\section{Frühere SSL-/TLS-Versionen und TLS 1.3}

Im Folgenden soll kurz auf frühere Versionen von TLS/SSL und die entscheidenden Unterschiede zwischen diesen Versionen eingegangen sowie ein kurzer Blick auf das noch nicht veröffentlichte TLS 1.3 geworfen werden.

\textbf{SSL 1.0} wurde nie veröffentlicht.

\textbf{SSL 2.0} war die erste Version, die öffentlich gemacht und auch patentiert wurde. In dieser Version bestanden einige große Schwachstellen: Der Handshake wurde noch nicht authentifiziert, so dass Angreifer beispielsweise die \ciphersuite-Liste unbemerkt verändern konnten, viele schwache kryptographische Algorithmen wurden unterstützt und für Verschlüsselung und MAC-Berechnung wurden die gleichen Schlüssel verwendet. Auf diese Schwachstellen wird teilweise genauer in Kapitel \ref{cha_attacks} eingegangen. Da die Spezifikation nicht veröffentlicht wurde, stammen diese Informationen aus \cite{meyer14}. Die Unterstützung von SSL 2.0 wird für TLS-Implementierungen durch RFC 6176 (\cite{prohibit_ssl20}) verboten.

In \textbf{SSL 3.0} wurden verschiedene Schlüssel zur Verschlüsselung und MAC-Berechnung eingeführt und die während der MAC-Berechnung genutzte Hashfunktion konfigurierbar gemacht (aber noch kein HMAC verwendet). Der Handshake wurde authentifiziert (durch den Inhalt der \finished{}-Nachricht) und in die Generierung des \premastersecret{} floss die Versionsnummer ein, um Version-Rollback-Angriffe zu verhindern. Außerdem wurden neue kryptographische Algorithmen eingeführt und weitere kleine Änderungen vorgenommen (vgl. \cite{ssl30}). Von der Abwärtskompabilität von TLS-Implementierungen zu SSL 3.0 wird in RFC 7568 (\cite{deprecate_ssl30}) abgeraten.

\textbf{TLS 1.0} ist großenteils äquivalent zu SSL 3.0. Es wurde die Pseudo Random Function eingeführt, die allerdings noch anders spezifiziert war als in der aktuellen Version. Die Berechnung des MACs erfolgte nun durch eine HMAC-Konstruktion. Außerdem wurde eine \changecipherspec{}-Nachricht vor der \finished{}-Nachricht vorgeschrieben, um den DropChangeCipherSpec-Angriff zu verhindern (vgl. \cite{tls10}).

In \textbf{TLS 1.1} wurden explizite Initialisierungsvektoren für Blockchiffren im CBC-Modus vorgeschrieben, um den in Abschnitt \ref{sec_known_ivs} vorgestellten Angriff zu verhindern. Das Verhalten bei Padding-Fehlern wurde vorgeschrieben, um den Bleichenbacher-Angriff zu verhindern. Außerdem wurden die exportgeschwächten \ciphersuites{} aus der Spezifikation entfernt (vgl. \cite{tls11}).

In \textbf{TLS 1.2} wurde der Gebrauch von SHA1 und MD5 in der Pseudo Random Function durch eine \ciphersuite{}-abhängige Hashfunktion ersetzt. Zusätzlich wurde die Unterstützung von AEAD-\ciphersuites{} eingefügt. TLS-Extensions und der Gebrauch von AES als Blockchiffre wurden ergänzt. Außerdem wurden DES und IDEA als Blockchiffren aus der Spezifikation entfernt, die Unterstützung von SSL 2.0 nicht mehr empfohlen und weitere kleine Änderungen vorgenommen (vgl. \cite{tls12}).

\textbf{TLS 1.3} liegt momentan lediglich als Draft vor (\cite{tls13}, Version von Juli 2015]). Die hier dargestellten Informationen stellen also lediglich den aktuellen Entwicklungsstand dar und sind daher nicht als endgültig und nur mit Vorsicht zu betrachten.\\
In dem aktuellen Draft wird Elliptic Curve Cryptography für das Diffie-Hellman-Verfahren hinzugefügt, die Unterstützung für alle SSL-Versionen und auch Kompression komplett entfernt (wahrscheinlich als Maßnahme gegen den Angriff aus Abschnitt \ref{sec_attack_crime}). Die größte Veränderung ist die Ausmusterung von Strom- und Blockchiffren im CBC-Modus zur Verschlüsselung. Es werden nur noch AEAD-Chiffren unterstützt, womit auch die separate Berechnung eines MACs entfällt. Außerdem wurde die PRF-Konstruktion durch die Verwendung von HKDF (HMAC-based Key Derivation Function, siehe \cite{krawczyk10}) ersetzt.

\todo{https://www.trustworthyinternet.org/ssl-pulse/ - SSL-Versionsverbreitung ergänzen?}

\ifoptionfinal{}{
\begin{description}
	\item[TLS 1.0] RFC 2246 - \url{http://tools.ietf.org/html/rfc2246}
	\item[TLS 1.1] RFC 4346 - \url{http://tools.ietf.org/html/rfc4346}
	\item[TLS 1.2] RFC 5246 - \url{http://tools.ietf.org/html/rfc5246}
	\item[TLS 1.3] Draft -\url{https://tools.ietf.org/html/draft-ietf-tls-tls13-07}
	\item[TLS Extensions] Z.B.\\
		RFC 3546 - \url{http://tools.ietf.org/html/rfc3546}, \\
		RFC 3466 - \url{http://tools.ietf.org/html/rfc4366}, \\
		RFC 6066 - \url{http://tools.ietf.org/html/rfc6066}
\end{description}
}

\section{Implementierungen}

Kurz sollen hier auch noch bestehende Implementierungen von SSL/TLS erwähnt werden, auch wenn der Fokus der Arbeit auf der Protokollspezifikation selber liegt.

Die meistgenutzte Implementierung, die unter anderem auch im häufig verwendeten Apache-Webserver zum Einsatz kommt, ist OpenSSL, eine Open-Source-Implementierung in C. In Produkten von Microsoft wird die Bibliothek SChannel, in Apple-Anwendungen Secure Transport und in Google Chrome und Mozilla-Produkten NSS verwendet. Auch manche Programmiersprachen bringen eigene Implementierungen mit. Ein Beispiel hierfür ist die Java Secure Socket Extension (JSSE).

Zusätzlich gibt es viele weitere seltener genutzte Implementierungen wie GnuTLS, PolarSSL, LibreSSL oder Amazon s2n, die vollständig neu entwickelt wurden oder als Forks bestehender Implementierungen entstanden sind.

Viele Angriffe auf TLS-gesicherte Verbindungen, die bekannt geworden sind, waren Angriffe auf Implementierungen und nicht auf die Protokollspezifikation selbst (auf diese zweite Art von Angriffen wird in Kapitel \ref{cha_attacks} eingegangen). Ein Beispiel ist der Heartbleed\footnote{http://heartbleed.com/} getaufte Bug in OpenSSL, der es wegen eines Programmierfehlers ermöglichte, Speicherinhalte des Servers auszulesen. Auf solche Angriffe, die lediglich einzelne Implementierungen betreffen, soll im Rahmen dieser Arbeit nicht weiter eingegangen werden.

Eine gelungene Übersicht über bestehende Implementierungen, die tiefer ins Detail geht, ist in \cite{meyer14} zu finden.
%https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations
