\chapter{Funktionsweise und Teilprotokolle}

\lstdefinestyle{pdu}{
	numbers=none,
	frame=leftline,
	escapeinside={§}{§}
}

\lstset{style=pdu}

Die Informationen in diesem Abschnitt stammen überwiegend aus der TLS 1.2-Spezifikation (\cite{tls12}). Für einen ersten Überblick wurde \cite{eckert13} genutzt.
\todo{Zum Einstieg grobe Funktionsbeschreibung, evtl. schon mit Grafik über Verbindungsaufbau?, Grafik der TLS-Protokolle}

In der oberen Schicht sind vier Teilprotokolle spezifiziert: \handshakeprotocol{}, \changecipherspecprotocol{}, \alertprotocol{} und \applicationdataprotocol{}.









%\section{\ciphersuites{}}

%--------------------------------------------------------------------------------------------------------

\section{Record Protocol}
\todo{Kapitel evtl. hinter den Handshake? Und vorher auf Schlüsselberechnung eingehen?}
TLS besteht aus zwei Schichten. In der unteren Schicht befindet sich das \recordprotocol{}, das die Daten von den Teilprotokollen der oberen Schicht entgegennimmt, diese Protokolldaten fragmentiert (maximale Paketgröße \(2^{14}\) Byte) und optional komprimiert. Danach wird je nach (während des Handshakes) verhandelten kryptographischen Funktionen die Integrität der Daten durch Berechnen und Anhängen eines MACs gesichert und die Nachricht verschlüsselt\footnote{Achtung: hier wird MAC-then-Encrypt angewendet. Laut \cite{AE2000} ist Encrypt-then-MAC vorzuziehen. In \cite{krawczyk01} wird dieses Ergebnis bestätigt, aber auch die Sicherheit von authenticate-then-encrypt unter bestimmten Voraussetzungen gezeigt.}. 
\todo{Nach http://crypto.stackexchange.com/a/224 schlägt Schneier in Cryptography Engineering MAC-then-encrypt aus Gründen der Komplexheit von Encrypt-then-MAC vor. Nachlesen! Gibt es in der Informatik-Bibliothek: T FER 45399} 



Der Record-Header enthält Informationen über die verwendete SSL-/TLS-Version, den Content-Type (Handshake, Alert, ChangeCipherSpec, ApplicationData) und die Länge des Klartextfragments.\todo{PDUs einbauen}


Die Integrität der Daten, die aus einem der Protokolle der oberen Schicht an das \recordprotocol{} gesendet werden, wird zuerst mit einem MAC geschützt, der folgendermaßen berechnet wird:
\begin{lstlisting}
MAC(MAC_write_key, seq_num +
				   TLSCompressed.type +
				   TLSCompressed.version +
				   TLSCompressed.length +
				   TLSCompressed.fragment);
\end{lstlisting}
Bei den in TLS verwendeten \ciphersuites{} wird das HMAC-Verfahren zur Berechnung des MACs genutzt. Details zu diesem Verfahren sind in \cite{hmac97} zu finden. Die hierbei verwendete Hashfunktion wird in der \ciphersuite{} angegeben. Bei SSL 3.0 wurde hier noch eine HMAC-ähnliche Konstruktion verwendet.\todo{In Versionsunterschiede auslagern?}

Danach wird der Klartext zusammen mit dem MAC optional mit Padding versehen (bei Nutzung von Blockchiffren), verschlüsselt und dann verschickt.


\section{Berechnung des Schlüsselmaterials}

aus Zufallszahl des Clients \(R_C \text{ aus } H_C\), Zufallszahl des Servers \(R_S \text{ aus } H_S\) und \premastersecret{} wird das \mastersecret{} berechnet.
\begin{lstlisting}
master_secret = PRF(pre_master_secret, 
					"master secret",
					ClientHello.random + ServerHello.random)[0..47];
\end{lstlisting}

%TODO: Vielleicht auch ausgliedern in Handshake?
%----------
Aus dem nach Ausführung des \handshakeprotocol{} (siehe nächsten Abschnitt) beidseitig bekannten \mastersecret{} werden Schlüssel für die Erstellung des MACs sowie für die Kommunikation zwischen Client und Server berechnet (also insgesamt vier Schlüssel). Dazu werden solange Schlüsselblöcke nach dem folgenden Verfahren erstellt, bis alle Schlüssel konstruiert werden können. 

\begin{lstlisting}
key_block = PRF(SecurityParameters.master_secret,
                "key expansion",
                SecurityParameters.server_random +
                SecurityParameters.client_random);
\end{lstlisting}

Hierbei werden die folgenden Funktionen genutzt:

\begin{lstlisting}
PRF(secret, label, seed) = P_hash(secret, label + seed)

P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
					   HMAC_hash(secret, A(2) + seed) +
					   HMAC_hash(secret, A(3) + seed) + ...

A(0) = seed
A(i) = HMAC_hash(secret, A(i-1))
\end{lstlisting}

\section{TLS-Handshake}

Das \handshakeprotocol{} dient zur Herstellung einer gesicherten Verbindung. Hierbei werden kryptographische Verfahren zwischen den Kommunikationspartnern vereinbart, optional ihre Identitäten authentifiziert und ein gemeinsames Geheimnis (das sogenannte \premastersecret{}) für die bereits beschriebene Generierung der während der eigentlichen Kommunikation verwendeten Schlüssel übertragen oder berechnet. Eine Übersicht über die während eines vollständigen Handshakes ausgetauschten Nachrichten bietet Abbildung \ref{fig_complete_handshake}. 

Im Folgenden werden diese Nachrichten und ihr Aufbau im Detail betrachtet. Nachrichten, die - je nach gewünschten Eigenschaften der Verbindung - optional gesendet werden können, sind mit einem Stern(*) gekennzeichnet.

%TODO:
% - Übersicht über den Handshake (auf Grafik eingehen)
% - Aushandeln der SecurityParameters (struct vorhanden)

\begin{figure}[]%H
	\centering
	\begin{lstlisting}
Client                                               Server

                             <--------        HelloRequest*
ClientHello                  -------->
                                                ServerHello
                                               Certificate*
                                         ServerKeyExchange*
                                        CertificateRequest*
                             <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                         [ChangeCipherSpec]
                             <--------             Finished
Application Data             <------->     Application Data
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim vollständigen TLS-Handshake. Entnommen aus \cite{tls12}.}
	\label{fig_complete_handshake}
\end{figure}

\subsection*{HelloRequest*}

\begin{lstlisting}
struct { } HelloRequest;
\end{lstlisting}

Diese Nachricht kann vom Server gesendet werden, wenn ein neuer Handshake gewünscht wird (beispielsweise um Schlüssel und kryptographische Funktionen während einer Verbindung neu auszuhandeln).

\subsection*{ClientHello}

\begin{lstlisting}
struct {
	ProtocolVersion client_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suites<2..2^16-2>;
	CompressionMethod compression_methods<1..2^8-1>;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ClientHello;
\end{lstlisting}

Hierbei enthält \datafield{client\_version} die neueste vom Client unterstützte TLS-/SSL-Version (z.B. 3.3 für TLS 1.2). 
\datafield{random} besteht aus einem 4-Byte großen Zeitstempel (UNIX-Format) und 28 zufälligen Bytes. 
Die \datafield{session\_id} dient zur Identifikation einer Sitzung. Sie ist bei dem ersten Handshake leer und kann später dazu verwendet werden, bestehende Sitzungen wieder aufzunehmen (vgl. Abschnitt \ref{sec_session_connection}). 
Die \ciphersuite{}-Liste enthält alle vom Client unterstützten \ciphersuites{} in Reihenfolge seiner Präferenz. 
Ebenso wird eine Liste von unterstützten Kompressionsalgorithmen übertragen. 
Optional kann auch eine Liste von gewünschten TLS-Extensions angegeben werden (vgl. refbla\todo{Abschnitt über TLS extensions vgl. TLS1.2 - 7.4.1.4}).

\subsection*{ServerHello}

\begin{lstlisting}
struct {
	ProtocolVersion server_version;
	Random random;
	SessionID session_id;
	CipherSuite cipher_suite;
	CompressionMethod compression_method;
	select (extensions_present) {
	  case false:
	      struct {};
	  case true:
	      Extension extensions<0..2^16-1>;
	};
} ServerHello;
\end{lstlisting}

In \datafield{server\_version} steht die höchste Version, die Server und Client unterstützen und die damit für die Kommunikation verwendet wird. \datafield{random} besteht äquivalent zur \clienthello{}-Nachricht aus einem 4-Byte Zeitstempel und 28 zufälligen Bytes. Die \datafield{session\_id} enthält entweder eine neu generierte ID, die ID einer wieder aufgenommen Sitzung oder kann auch leer sein, um anzugeben, dass die Sitzung nicht wieder aufgenommen werden kann. In \datafield{cipher\_suite} und \datafield{compression\_method} überträgt der Server die von ihm aus den vom Client übertragenen Listen ausgewählte \ciphersuite{} bzw. den Kompressionsalgorithmus. In der Extensionliste gibt der Server alle vom Client gewünschten Extensions an, die er unterstützt.

\subsection*{ServerCertificate*}

\begin{lstlisting}
struct {
	ASN.1Cert certificate_list<0..2^24-1>;
} Certificate;
\end{lstlisting}

In dieser Nachricht sendet der Server seine Zertifikatskette zur Überprüfung seiner Identität. Das erste Zertifikat in der Liste bildet das Serverzertifikat, folgende Zertifikate müssen das jeweils vorhergehende zertifizieren. Der im Zertifikat enthaltene Public Key muss zum ausgehandelten Schlüsselaustausch-Algorithmus passen. Wenn nicht anders ausgehandelt wird für die Zertifikate das X.509v3-Format verwendet.\todo{RFC als Quelle}

\subsection*{ServerKeyExchange*}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case dh_anon:
	      ServerDHParams params;
	  case dhe_dss:
	  case dhe_rsa:
	      ServerDHParams params;
	      digitally-signed struct {
	          opaque client_random[32];
	          opaque server_random[32];
	          ServerDHParams params;
	      } signed_params;
	  case rsa:
	  case dh_dss:
	  case dh_rsa:
	      struct {} ; /* message is omitted for rsa, dh_dss, and dh_rsa */
	};
} ServerKeyExchange;
\end{lstlisting}

Diese Nachricht wird nur für bestimmte Schlüsselaustausch-Algorithmen gesendet, wenn die \servercertificate{}-Nachricht nicht genügend Informationen zum Austausch des \premastersecret{} bietet (vgl. \clientkeyexchange{}-Nachricht).

\subsection*{CertificateRequest*}

\begin{lstlisting}
struct {
	ClientCertificateType certificate_types<1..2^8-1>;
	SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
	DistinguishedName certificate_authorities<0..2^16-1>;
} CertificateRequest;
\end{lstlisting}

TLS unterstützt optionale Clientauthentifizierung. Mit dieser Nachricht kann der Client vom Server aufgefordert werden ebenfalls ein Zertifikat zu senden. Die \datafield{certificate\_types}-Liste enthält alle Zertifikatarten (z.B. Zertifikat mit RSA-Schlüssel, ...), die vom Server unterstützt werden, und \datafield{supported\_signature\_algorithms} die unterstützten Signaturalgorithmen. In \datafield{certificate\_authorities} kann eine Liste von erwarteten CAs übertragen werden.

\subsection*{ServerHelloDone}

\begin{lstlisting}
struct { } ServerHelloDone;
\end{lstlisting}

Mit dieser Nachricht signalisiert der Server das Ende des \serverhello{} und zugehöriger Nachrichten.

\subsection*{ClientCertificate*}

Wenn von dem Server eine Clientauthentifizierung gefordert wurde, kann der Client in dieser Nachricht seine Zertifikatskette senden. Das Format entspricht dem der \servercertificate{}-Nachricht.

\subsection*{ClientKeyExchange}

\begin{lstlisting}
struct {
	select (KeyExchangeAlgorithm) {
	  case rsa:
	      EncryptedPreMasterSecret;
	  case dhe_dss:
	  case dhe_rsa:
	  case dh_dss:
	  case dh_rsa:
	  case dh_anon:
	      ClientDiffieHellmanPublic;
	} exchange_keys;
} ClientKeyExchange;
\end{lstlisting}

Wenn RSA als Schlüsselaustausch-Algorithmus vereinbart wurde, so wird das \premastersecret{} mit dem Public Key des Servers verschlüsselt und gesendet. Es besteht aus der größten vom Client unterstützten Protokollversion (2 Bytes), um Version-Rollback-Angriffe zu verhindern (siehe Abschnitt \ref{sec_version_rollback}), und 46 zufällig generierten Bytes.

\begin{lstlisting}
struct {
	public-key-encrypted PreMasterSecret pre_master_secret;
} EncryptedPreMasterSecret;
\end{lstlisting}

Wenn der Schlüsselaustausch per Diffie-Hellman-Verfahren geschieht,...\todo{DH ergänzen, p.61}

\begin{lstlisting}
struct {
	select (PublicValueEncoding) {
	  case implicit: struct { };
	  case explicit: opaque dh_Yc<1..2^16-1>;
	} dh_public;
} ClientDiffieHellmanPublic;
\end{lstlisting}

\subsection*{CertificateVerify*}

\begin{lstlisting}
struct {
	digitally-signed struct {
	   opaque handshake_messages[handshake_messages_length];
	}
} CertificateVerify;
\end{lstlisting}

Diese Nachricht wird gesendet, falls ein Clientzertifikat vom Server angefordert wurde. Sie besteht aus einem mit dem Private Key des Clients signierten Hash der bisherigen Handshake-Nachrichten und dient dazu den Client zu authentifizieren.

\subsection*{ChangeCipherSpec}

Diese Nachricht gehört zum \changecipherspecprotocol{}. Es enthält lediglich diese eine Nachricht mit dem Wert 1. Das Empfangen signalisiert dem Empfänger, dass alle nachfolgend gesendeten Nachrichten mit den ausgehandelten kryptographischen Verfahren und Schlüsseln geschützt werden. Dazu werden read pending state (bei Empfang der Nachricht) und write pending state (nach Senden der Nachricht) in die current states kopiert.\todo{Irgendwo schon erwähnt oder bei der Einführung?}

\subsection*{Finished}

\begin{lstlisting}
struct {
	opaque verify_data[verify_data_length];
} Finished;
\end{lstlisting}

Die \finished{}-Nachricht dient zur Verifikation von erfolgreichem Schlüsselaustausch und Authentifikation. Diese Nachricht ist wie erwähnt die erste, die von den ausgehandelten Verfahren und Schlüsseln geschützt wird, daher kann hier überprüft werden, ob der Handshake erfolgreich verlaufen ist und beiden Kommunikationspartnern die gleichen Informationen vorliegen.

Die Nachricht besteht aus einem Hash über die bisher gesendeten bzw. empfangenen Nachrichten des \handshakeprotocol{}s zusammen mit dem \mastersecret{}:

\begin{lstlisting}
verify_data = PRF(master_secret, 
				  finished_label, 
				  Hash(handshake_messages)) [0..verify_data_length-1];
\end{lstlisting}

Das \datafield{finished\_label} wird durch \inquotes{client finished} auf der Client- bzw. \inquotes{server finished} auf der Serverseite gebildet. Der Hash wird durch die in der PseudoRandomFunction verwendete Hashfunktion berechnet. \todo{Irgendwo drauf eingehen} \datafield{verify\_data\_length} entspricht, wenn durch die \ciphersuite{} nicht anders vorgegeben, 12 Bytes Länge.

\section{Alert Protocol}

Das \alertprotocol{} dient dazu, auftretende Fehler zu versenden, die während des Datenaustausches auftreten. Hierbei kann es sich zum Beispiel um fehlgeschlagene Überprüfung von entschlüsselten Nachrichten (\badrecordmac{}) oder fehlerhafte Zertifikatsüberprüfung (\badcertificate{}) handeln. Unterschieden wird zwischen Fehlern (fatal alert), die sofort zum Schließen der Sitzung führen, und Warnungen(warning alert). Eine Übersicht über alle Fehler findet sich in Abschnitt 7.2 von \cite{tls12}.

\section{Application Data Protocol}

Das \applicationdataprotocol{} ist zuständig für das Durchreichen von Anwendungsdaten, die von der Anwendungsschicht gesendet werden sollen.

\section{Sitzungs- und Verbindungskonzept}
\label{sec_session_connection}

\todo{Wo passt das Kapitel hier denn am Besten hin?}

TLS erstellt beim ersten Handshake eine Sitzung zwischen Client und Server. Hierbei wird ein Sitzungsidentifikator erstellt, der beim \serverhello{} mitgesendet wird. Weiterhin wird sich in der Sitzung das Zertifikat des Gegenübers, optional das Kompressionsverfahren, die \ciphersuite und das \mastersecret{} gemerkt.

Ein Client kann nun, wenn er den Sitzungsidentifikator beim \clienthello{} mitschickt, eine alte Sitzung in Form einer neuen Verbindung wiederaufnehmen oder mehrere Verbindungen parallel aufbauen. Eine Verbindung wird dabei durch Client- und Server-Zufallszahlen \(R_C\) und \(R_S\), die generierten Schlüssel, je nach verwendeten Verschlüsselungsverfahren einen Initialisierungsvektor, sowie aktuelle Sequenznummern beschrieben.

Beim Verbindungsaufbau kann so ein verkürzter Handshake genutzt werden, bei dem weniger Nachrichten gesendet werden müssen. Es kann dabei auf Neuberechnung des \mastersecret{}, Server- und Client-Validierung und Aushandlung der \ciphersuite{} verzichtet werden.

\begin{figure}[]%H
	\centering
	\begin{lstlisting}
Client                                                Server

ClientHello                   -------->
                                                 ServerHello
                                          [ChangeCipherSpec]
                              <--------             Finished
[ChangeCipherSpec]
Finished                      -------->
Application Data              <------->     Application Data
	\end{lstlisting}
	\caption{Nachrichtenverlauf beim abgekürzten TLS-Handshake. Entnommen aus \cite{tls12}.}
	\label{fig_abbreviated_handshake}
\end{figure}





\section{Frühere SSL-/TLS-Versionen und TLS 1.3}


%---------------------------------------------------------------------------------------------------

%p. 18/p. 77
\begin{lstlisting}
struct {
	ConnectionEnd          entity;
	PRFAlgorithm           prf_algorithm;
	BulkCipherAlgorithm    bulk_cipher_algorithm;
	CipherType             cipher_type;
	uint8                  enc_key_length;
	uint8                  block_length;
	uint8                  fixed_iv_length;
	uint8                  record_iv_length;
	MACAlgorithm           mac_algorithm;
	uint8                  mac_length;
	uint8                  mac_key_length;
	CompressionMethod      compression_algorithm;
	opaque                 master_secret[48];
	opaque                 client_random[32];
	opaque                 server_random[32];
} §\textbf{SecurityParameters}§;
\end{lstlisting}

%p. 19
\begin{lstlisting}
 struct {
	ContentType type;  
	ProtocolVersion version; 
	uint16 length;
	opaque fragment[TLSPlaintext.length];
} §\textbf{TLSPlaintext}§;

enum { //eher erklaeren als uebernehmen
	change_cipher_spec(20), alert(21), handshake(22), application_data(23),(255)
} §\textbf{ContentType}§;

struct { //eher erklaeren als uebernehmen
	uint8 major;
	uint8 minor;
} §\textbf{ProtocolVersion}§;
\end{lstlisting}

%p. 21
\begin{lstlisting}
 struct {
	ContentType type;       /* same as TLSPlaintext.type */
	ProtocolVersion version;/* same as TLSPlaintext.version */
	uint16 length;
	opaque fragment[TLSCompressed.length];
} §\textbf{TLSCompressed}§;
\end{lstlisting}

%p.21
\begin{lstlisting}
struct {
	ContentType type;       /* same as TLSCompressed.type */
	ProtocolVersion version;/* same as TLSCompressed.version */
	uint16 length;
	select (SecurityParameters.cipher_type) { //eher erklaeren als uebernehmen -> p.22 ff
	    case stream: GenericStreamCipher;
	    case block:  GenericBlockCipher;
	    case aead:   GenericAEADCipher;
	} fragment;
} §\textbf{TLSCiphertext}§;
\end{lstlisting}
